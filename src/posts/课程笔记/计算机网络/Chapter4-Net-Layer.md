---
title: Chapter4 Net Layer
# cover: /assets/images/cover1.jpg
icon: page
# This control sidebar order
order: 1
author: ChiChen
date: 2023-06-18
category:
  - 课程笔记
tag:
  - 计算机网络
# this page is sticky in article list
sticky: false
# this page will appear in starred articles
star: false
footer: 
isOriginal: true
copyright: 转载请注明出处
---

## 路由器工作原理

### 输入端口处理和基于目的地转发

![[输入端口处理.png]]

#### 最长前缀匹配(Longest Prefix Match LPM)

- 用来决定路由器如何进行转发，例如下表，其中link表示当前路由器连接到其他路由器的不同链路，当地址为28.1.2.3时，选择链路3，当地址为28.33.5.4时，选择链路4

|dest|link|
|---|---|
|default|1|
|171.33.0.0/16|5|
|23.0.0.0/24|2|
|28.0.0.0/24|3|
|28.33.5.0/8|4|

- 在输入端口处理中，除了“查找”之外，还要进行：
  1. 物理层和链路层处理
  2. 检查packet的版本号、校验和以及寿命字段，并重写后两个字段(因为TTL递减了，所以要重算校验和)
  3. 更新用于网络管理的计数器。

### 交换

- 交换也就是转发(forward)，即从一个输入端口把数据转发到一个输出端口中，有许多实现方法

![[交换方法.png]]

- 还有的会使用并行的方法，例如有N个并行的交换结构，在输入端口把packet分为K个块，通过N个交换结构中的K个把这些块发送到输出端口中，最后再在输出端口进行组装。

### 输出端口处理

![[输出端口处理.png]]

### 排队产生

##### 输入排队

- 图示被称为线路前部(Head-Of-Line, HOL)阻塞，即虽然输出端口空闲，但是它被位于线路前部的一个packet所阻塞
![[HOL阻塞.png]]

##### 输出排队

- 当输出端口没有足够内存来缓存一个新到的packet时，就必须做出决定：要么丢弃到达的分组（采用一种称为弃尾(drop-tail)的策略），要么删除一个或多个已排队的packet来腾出位置。这些策略被称为主动队列管理(Active Queue Management, AQM)算法。随机早期检测(Random Early Detection, RED)算法是广泛使用的算法。
![[输出端口排队.png]]
- 输出端口需要进行分组调度(packet scheduler)来从这个队列中取出一个packet进行传输
- 缓存的数量(B)应当由以下公式给出(C为链路的容量)：

$$\begin{array}{c}
B=RTT\cdot C(少量TCP流)\\
B=RTT\cdot C/\sqrt{N}(大量TCP流，N条)
\end{array}$$

### 分组调度

- FIFO
- 优先权队列：通常是由网络操作员设定某些特定IP/端口号的优先级，来识别类似网络管理信息的packet
- 循环和加权公平排队：把packet分类，在每个类之间循环。

## IPv4、寻址、IPv6及其他

### IPv4数据报格式

![[IPv4数据包格式.png]]
- 版本（号）。这4比特规定了数数据报的 $IP$ 协议版本。通过查有欣本号，路由器能够确定如何解释 $IP$ 数据报的剩余部分。不同的 $IP$ 版本使用不同的数据报格式IPv4的数据报格式如图 4-16所示。新版本的IP（IPv6）的数据报格式将在后面讨论。
- 首部长度。因为一个 $IPv4$ 数据报可包含一些可变数量的选项（这些选项包括在IPv4数据报首部中），故需要用这4比特来确定 $lP$ 数据报中载荷（例如在这个数据报中被封装的运输层报文段）实际开始的地方。大多数IP数据报不包含选项所以一般的 $IP$ 数据报具有20字节的首部。

- 服务类型。服务类型（10S）比特包含在 $IPv4$ 自部中，以便使不同类型的 $IP$ 数据报（例如，一些特别要求低时延、高吞吐量或可靠性的数据报）能相互区别开米。例如，将实时数据报（如用于 $IP$ 电话应用）与非实时流量（如FTP）区分开也许是有用的。提供特定等级的服务是一个由网络管理员对路由器确定和配置的策略问题。

- 数据报长度。这是 $IP$ 数据报的总长度（首部加上数据），以字节计。因为该字段长为16 比特，所以IP数据报的理论最大长度为 65 535字节。然而，数据报很少有超过1500字节的，该长度使得 $IP$ 数据报能容纳最大长度以太网帧的载荷字段。

- 标识、标志、片偏移。这三个字段与所谓 $IP$ 分片有关，这是一个我们将很快要考虑的主题。有趣的是，新版本的IP（即IPv6）不允许在路由器上对分组分片

- 寿命。寿命（Time-To- Live，I1L）子段用来确保数据报不会永远（如由于长时的路由选择环路）在网络中循环。每当一台路由器处理数据报时，该子段的值减1。若TTL字段减为0，则该数据报必须去弃。

- 协议。该字段通常仅当一个 $IP$ 数据报到达其最终目的地时才会有用。该字段值指示了 $IP$ 数据报的数据部分成交给哪个特定的运输层协议。例如，值为6表明数据部分要交给TCP，而值为17表明数据要交给UDP。注意在 $IP$ 数据报中的协议号所起的作用，类似于运输层报文段中端口号字段所起的作用。协议号是将网络层与运输层绑定到一起的黏合剂，而端口号是将运输层和成用层绑定到一起的黏合剂。我们将在第6章看到，链路层帧也有一个特殊字段用于将链路层与网络层绑定到一起。

- 首部检验和。自部检验利用于带助路田番检测收到的 $\mathrm{IP}$ 效话报中的比特铺误。自部检验和是这样计算的：将首部中的每2个字节当作一个数，用带回卷的加法对这些数求和。如在3.3节讨论的那样，该和的反码（被称为因特网检验和）存放在检检机子段中。路由器要对每个收到的 $\mathrm{IP}$ 数据报计算其首部检验和，如果数据报自部中携带的检验和与计算得到的检验和不一致，则检测出是个差错。路由器一般会夫弃检测出错误的数据报。注意到在每台路由器上必须重新计算检验和并再次存放到原处，因为TTL子段以及可能的选项子段会改变。关于计算因特网检验和的快速算法的有趣讨论参见[RFC 1071]。此时，一个经常问的问题是：为什么TCP/IP在运输层与网络层都执行差错检测？这种重复检测有几种原因。首先，注意到在IP层只对IP首部计算了检验和，而TCP/UDP检验和是对整个TCP/UDP报文段进行的。其次，TCP/UDP 与IP 不一定都必须属于同一个协议栈。原则上TCP能够运行在一个不同的协议（如ATM）上「Black 1995，而 $IP$ 能够携带不一定要传递给TCP/UDP的数据。

- 源和目的IP地址。当某源生成一个数据报时，它在源 $\mathrm{IP}$ 子段中插人它的IP地址，在目的 $IP$ 地址字段中插入其最终目的地的地址。通常源主机通过DNS查找来决定日的地址，如在第2章中讨论的那样。我们将在4.3.3节中详细讨论 $IP$编址

- 选项。选项子段允许 $IP$首 部被扩展。自部选项意味看很少使用，因此决定对每个数据报首部不包括选项字段中的信息，这样能够节约开销。然而，少量选项的存在的确使问题复张了，因为数据报首部长度可变，故不能预先确定数据子段从何处开始。而且还因为有些数据报要求处理选项，而有些数据报则不要求，故导致一台路由器处理一个 $IP$ 数据报所需的时间变化可能很大。这些考虑对于高性能路由器和主机上的 $IP$ 处理来说特别重要。由于这样或那样的原因，在IPv6首部中已去掉了IP选项

- 数据（有效载荷)。我们来看看最后也是最重要的字段，这是数据报存在的首要理由！在大多数情况下，IP数据报中的数据子段包含要交付给日的地的运输层报文段（TCP或UDP)。然而，该数据字段也可承载其他类型的数据，如ICMP报文

### IPv4 数据报分片

- 对于一个网络传输的过程，不同的链路层实现会对最大传输单元MTU由不同的限制，有可能出现IP数据报大于MTU的情况，这时候就要分片再重组
- $IP v4$的设计者将标识、标志和片偏移字段放在 $\mathrm{IP}$ 数据报自部中。当生成一个数据报时，发送王机在为该数据报设置源和日的地址的同时贴上标识号。发送主机通常将它发送的每个数据报的标识号加1。当某路由器福要对一个数据报分片时，形成的每个数据报（即片）具有初始数据报的源地址、日的地址与标识号。当目的地从同一发送主机收到一系列数据报时，它能够检管数据报的标识号以确定哪些数据报实际上是同一较大数据报的片。由于IP是一种不可靠的服务，一个或多个片可能永远到达不了目的地。因为这种原因，为了让目的主机绝对地相信它已收到了初始数据报的最后一个片，最后一个片的标志比特被设为0，而所有其他片的标志比特被设为1。另外，为了让目的主机确定是否丢失了一个片（且能按正确的顺序重新组装片），使用偏移字段指定该片应放在初始 $\mathrm{IP}$ 数据报的哪个位置

### IPv4 编址

#### 组成

- 由4个八位组(octets)构成的32bits长的地址：a.b.c.d
 - 例如：171.64.64.64、19.168.3.1、255.255.255.255

#### 子网掩码
- 是从最高有效位开始的一串连续的1
- 用地址1与子网掩码进行位相与操作，如果和地址2与子网掩码进行位相与的结果一样，则说明这两个地址处于一个子网下，不会发送至IP路由器，而是会在本地网络中进行查找
- 例如：255.255.255.0表示前三个八位组相同

#### 地址分配

##### A、B、C分类(历史上的方法)

|Type|Sign Bit|Network|Host|
|---|---|---|---|
|Class A|0|network(7)|host(24)|
|Class B|10|network(14)|host(16)|
|Class C|110|network(21)|host(8)

##### CIDR(Classless Inter-Domain Routing)
- 地址块是由地址(Address)和计数(Count)组成的
- CIDR用斜线记法，又称斜线记法来表示网络前缀所占的比特数，因此IP地址被分为$<网络前缀>和<主机号>$两部分，例如171.64.0.0/16表示从171.64.0.0到171.64.255.255的全部地址，地址$A/n$能表示$2^{32-n}$个IP地址
- 所有地址被分为A/8分给各个大洲的RIR，并由各自的RIR决定如何进行地址分配

- 特别的，255.255.255.255这个地址会被交付给网络上的所有主机。路由器也会有选择地向邻近的子网转发该报文(虽然一般不这么做)

#### 获取地址

1. 获取一块地址：由ICANN向ISP提供一块地址，然后ISP再向其客户提供这一块地址中的一部分。
2. 获取主机地址：用动态主机配置协议(Dynamic Host Configuration, DHCP)来完成。DHCP可以由配置来让某给定主机每次与网络连接都有一个相同的IP地址，或者某主机会被分配一个可变的临时IP地址。除此之外，DHCP还允许一台主机获知其他信息，例如它的子网掩码、第一跳路由器地址(常称为默认网关)与它的本地DNS服务器地址。

##### DHCP过程

- DHCP协议是一个四步的过程，yiaddr表示分配给该新到达客户的地址:
  1. DHCP服务器发现。一台新到达的主机的首要任务是发现一个要与其交互的DHCP服务器。这可通过使用DHCP发现报文（DHCP discover message）来完成，客户在UDP分组中向端口67发送该发现报文。该 $UDP$ 分组封装在一个 IP数据报中。但是这个数据报应发给谁呢？主机甚至不知道它所连接网络的 $\mathrm{IP}$ 地址，更不用说用于该网络的DHCP服务器地址了。在这种情况下，DHCP客户生成包含DHCP发现报文的IP数据报，其中使用广播目的地址255. 255,255. 255并且使用“本主机”源 $IP$ 地址0.0.0.0。DHCP客户将该 $IP$ 数据报传递给链路层，链路层然后将该帧广播到所有与该子网连接的节点
  2. DHCP服务器提供。DHCP服务器收到一个 DHCP发现报文时，用DHCP提供报文（DHCP offer message）向客户做出响应，该报文向该子网的所有节点广播，仍然使用IP广播地址255.255. 255.255（你也许要思考一下这个服务器为何也必须采用广播）。因为在于网中可能存在几个 DHCP服务器，该客户也许会发现它处于能在几个提供者之间进行选择的优越位置。每台服务器提供的报文包含有收到的发现报文的事务ID、向客户推荐的IP地址、网络掩码以及IP 地址租用期（ad-dress lease time），即 IP地址有效的时间量。服务器租用期通常设置为几小时或几天。
  3. DHCP请求。新到达的客户从一个或多个服务器提供中选择一个，并向选中的服务器提供用DHCP请求报文(DHCP request message)进行响应，回显配置的参数
  4. DHCP ACK。服务器用DHCP ACK报文(DHCP ACK message)对DHCP请求报文进行响应，证实所要求的参数。
![[DHCP过程.png]]

- DHCP无法支持移动性的连接，因为每当连到一个新子网就要获取一个新的IP地址，之前的TCP连接也就无法维持了。

### 网络地址转换(NAT)

![[NAT.png]]

- 如上图，局域网内10.0.0.1的3345端口发出请求，经过NAT后，把源端口号修改为5001，源IP地址修改为路由器的IP地址138.76.29.7，这样一来，通过保存这个映射表(NAT 转换表)，就可以实现NAT的功能

### IPv6

![[IPv6 header.png]]

#### 主要变化

- 扩大的地址容量：地址从32位变成了128位。还引入了任播地址(anycast address)，这种地址可以使数据报交付给一组主机中的任意一个
- 简化高效的40字节header：删除了一些被舍弃的IPv4字段
- 流标签：用来给特殊流的packet加上标签，例如需要实时服务的流
- Hop limit和Next hdr分别对应TTL和upper layer protocol。
- 而且不再有分片(如果过大就发送一个“分组过大”的ICMP差错报文)、校验和、可选字段

## ICMP(Internet Control Message Protocol)

### 网络层运转

1. IP协议
2. 路由表(Routing Tables)
3. ICMP(严格来说属于传输层协议，因为它是被IP协议使用的)

### 运作方式

- 当一个IP datagram产生异常，需要回传消息的时候，会按以下方法产生一个ICMP报文
 1. 把IP datagram的IP header和IP datagram的有效负载(data部分)的前八个字节作为ICMP message，也就是ICMP的有效负载
 2. 然后产生一个ICMP header，包括：
- 类型（Type）：8位，表示ICMP报文类型，如请求回显（Echo Request）和回显应答（Echo Reply）等。
- 代码（Code）：8位，表示ICMP报文类型的子类型，如请求回显的代码为0，回显应答的代码为0。
- 校验和（Checksum）：16位，用于检验ICMP报文的完整性。
- 标识符（Identifier）：16位，用于标识发送的ICMP报文。
- 序号（Sequence Number）：16位，用于标识发送的ICMP报文序列号。
 3. 然后再封装进一个新的IP datagram中，设置源和目标IP地址，protocol为1表示ICMP

### Traceroute实现方法

- traceroute是一个可以追踪途径的所有路由的命令
- 具体方法为：```

```cpp
 int TTL = 1;
 String desport = null(or some wrong port to rise a port unreachable);
 ICMP icmp;
 while(icmp!="port unreachable"){
  SendUDP(TTL++,desport);
  icmp = recieveICMP();
  /*output*/
 }
```

- 通过递增的TTL来表示第一跳、第二跳等经过的路由，并用port unreachable来表示抵达了终点

## 路由选择算法

- 简单来说就是想要在一个由路由器组成的图中找到一个开销最小的路径抵达目的地。

### 分类方法

#### 集中式vs分散式

- 集中式路由选择算法(Centralized routing algorithm)，计算时要求知道全局的路由状态，包括全局的连通性和链路开销信息。通常也被称为链路状态(Link State, LS)算法，因为该算法必须知道网络中每条链路的开销
- 分散式路由选择算法(Decentralized routing algorithm)。每次计算时只有预期直接相连的链路的开销信息。然后通过迭代计算以及与相邻节点的信息交换，逐渐计算出最低开销路径。后续会学习被称为距离向量(Distance-Vector, DV)算法。

#### 静态vs动态

- 静态路由选择算法 (static routing algorithm) 中，路由随时间的变化非常缓慢，通常是人工进行调整（如人为手工编辑 条链路开销）
- 动态路由选择算法 (dynamic routing algorithm) 随着网络流量负载或拓扑发生变化而改变路由选择路径 一个动态算法可周期性地运行或 直接响应拓扑或链路开销的变化而运行 虽然动态算法易于对网络的变化做出反应，但也 更容易受诸如路由选择循环、路由振荡之类问题的影响

#### 负载敏感vs迟钝

- 负载敏感算法 load-sensitive algorithm) 中，链路开销会动态地变化以反映出底层链路的 当前拥塞水平 如果当前拥塞的一条链路与高开销相联系，则路由选择算法趋向于绕开该 拥塞链路来选择路由 而早期的 ARPAnet 路由选择算法就是负载敏感的 , 所以遇到了许多难题。
- 当今的因特网路由选择算法（如 RIP OSPF BGP) 都是负载迟钝的 (load-insensitive) , 因为某条链路的开销不明确地反映其当 前（或最近）的拥塞水平。

### 链路状态路由选择算法(LS)

- 实际上就是Dijkstra算法：
![[LS算法.png]]
- 其中：
  - $D(v)$：到算法的本次迭代，从源节点到目的节点$v$的最低开销路径的开销
  - $p(v)$：从源到$v$沿着当前最低开销路径的前一个节点
  - $N'$：节点子集；如果源到$v$的最低开销路径已确定，则$v在N'$中。

- 例如：
![[LS算法示例图1.png]]
![[LS算法示例图2.png]]

- 线性查找下有$O(n^2)$的时间复杂度，用最小堆维护$N'$则有指数查找时间，总的时间复杂度就为$O(nlogn)$

### 距离向量路由选择算法

- 最低开销路径有著名的Bellman-Ford方程
$$d_x(y)=min_v\{c(x,v)+d_v(y)\}$$
- 其中$d_x(y)$是从节点$x$到节点$y$的最低开销路径的开销。$min_v$表示遍历$x$的每个邻居$v$取最小值。

#### 实际步骤

其基本思想如下。每个节点x以 $D_{x}\left(y\right)$ 开始，对在 $N$ 中的所有节点$y$，估计从$x$到$y$的最低开销路径的开销。令 $D(x)=[D_x(y):\;y\in N]$是节点$x$的距离向量，该向量是从$x$到在 $N$ 中的所有其他节点 $y$ 的开销估计向量。使用DV算法，每个节点 $x$ 维护下列路由选择信息:
1. 对于每个邻居$v$，从x到直接相连邻居 $v$ 的开销为 $c\left(x,v\right)$
2. 节点x的距离向量，即 $D_{x}=\left[D_{x}\left(y\right):y\in N\right]$ ，包含了x到 $N$ 中所有目的地 $y$ 的开销估计值。
3. 它的每个邻居的距离向量，即对$x$的每个邻居$v$，有$D_{v} =[D_v(y)：y \in N]$。

- 在该分布式、异步算法中，每个节点不时地向它的每个邻居发送它的距离向量副本当节点 $x$ 从它的任何一个邻居t接收到一个新距离向量，它保存v的距离向量，然后使用Bellman- Ford 方程更新它自己的距离向量如下:
$$D_{x}(y)=min_{v}\{c(x,v)+D_{v}(y)\}对 \text{N} 中的每个节点$$

如果节点 $x$ 的距离向量因这个更新步骤而改变，节点x接下来将向它的每个邻居发送其更新后的距离向量，这继而让所有邻居更新它们自己的距离向量。令人惊奇的是，只要所有的节点继续以异步方式交换它们的距离向量，每个开销估计 $D_x$ （y）收敛到$d_x(y)$,$d_{x}\left(y\right)$为从节点$x$到节点 $y$ 的实际最低开销路径的开销

![[DV算法.png]]
![[DV算法示例.png]]

## 自治系统(Autonomous System, AS)

- 在互联网中，一个自治系统(AS)是一个有权自主地决定在本系统中应采用各种路由协议的小型单位。这个网络单位可以是一个简单的网络也可以是一个由一个或多个普通的网络管理员来控制的网络群体，它是一个单独的可管理的网络单元（例如一所大学，一个企业或者一个公司个体）。一个ISP可能就是一个AS，也可能包含多个AS。
- 自治系统之间使用被称为网关路由器(gateway router)的路由器进行连接。
- 自治系统中所有的路由器必须相互连接，运行相同的路由协议，被称为自治系统内部路由选择协议(intra-autonomous system routing protocol)，同时分配同一个自治系统编号。所有自治系统之间用边际网关协议(Broder Gateway Protocol, BGP)作为自治系统间路由选择协议(inter-autonomous system routing protocol)。

### 自治系统内部路由选择协议

#### Routing Information Protocol (RIP)

- 基于DV算法，并把相邻路由器的权重都置为1，也就是说选取最少跳数的路径
- 在相邻的路由器之间传递信息。
- 大约每30秒更新一次

#### 开放最短路优先(OSPF)

- 基于LS算法，一台路由器构建了关于整个自治系统的完整拓扑图。于是每台路由器都在本地运行Dijkstra算法来确定一个以自己为根节点到所有子网的最短路径树。各条链路开销由管理员设定，或者直接设置为1(最少跳路径选择)。
- 使用OSPF时，会向自治系统内所有其他路由广播状态信息。每当一条链路状态发生变化时，路由器就会广播链路状态信息。即使链路信息未变化，也会至少每30分组广播一次链路状态。而OSPF通告包含在直接由IP承载的OSPF报文中，因此OSPF协议要自己实现诸如可靠报文传输等功能。

### 自治系统间路由选择协议——BGP

#### BGP的作用

- BGP的路由目的地是一个CIDR化的前缀，例如138.16.68/22，这个例子包含1024个地址。因此一台路由器的转发表将有$(x,I)$的表项，其中$x$是一个前缀，$I$是该路由器的接口之一的接口号。
- BGP为每台路由器提供了完成以下任务的手段：
  1. 从邻居AS获得前缀的可达性信息
  2. 确定到前缀的“最好的”路由

#### 通告BGP路由信息

- 位于AS边缘的被称为网关路由器(gateway router)，否则就是一台内部路由器(internal router)
- 在BGP中，每对路由器通过使用179端口的半永久TCP连接交换路由选择信息，称为BGP 连接。跨越两个AS的BGP连接被称为外部BGP(eBGP)，在相同AS中的两台路由器之间的BGP会话称为内部BGP(iBGP)连接。
![[eBGP和iBGP连接.png]]

- 为了传播可达性信息，使用了iBCP和 eBGP会话。再次考虑向ASI和 AS2中的所有路由器通告前缀 $x$ 的可达性信息。在这个过程中，网关路由器 $3a$ 先向网关路由器 $2c$ 发送一个eBGP报文“AS3$x^{\text{''}}$。网关路由器2c然后向AS2 中的所有其他路由器（包括网关路由器2a）发送iBGP报文“"AS3 x”。网关路由器2a接下来向网关路由器 $1c$ 发送一个eBCF报文“AS2 AS3 x”。最后，网关路由器 $1c$ 使用iBGP向AS1中的所有路由器发送报文“"AS2 AS3 x”。在这个过程完成后，在AS1和AS2中的每个路由器都知道了x的存在并且也都知道了通往x的AS路径

#### 确定最好的路由

- 当路由器通过 BGP 连接通告前缀时，它在前缀中包括一些 BGP 属性(BGP attribute)。用 BGP 术语来说，前缀及其属性被称为路由。两个较为重要的属性是 AS-PATH 和 NEXT-HOP。
- AS- PATH属性包含了通告已经通过的 $AS$ 的列表，如我们在前面的例子中所见。为了生成AS-PATH的值，当一个前缀通过某AS时，该AS将其ASN加人AS-PATH中的现有列表。例如，在下图中，从 AS1到子网x有两条路：其中一条使用AS- PATH“AS2 AS3”；而另一条使用AS-PATH“AS3”。BGP路由器还使用AS-PATH属性来检测和防止通告环路；特别是，如果一台路由器在路径列表中看到了包含它自己的AS，它将拒绝该通告。
- 在 $\mathrm{AS}$ 间和 $AS$ 内部路由选择协议之间提供关键链路方面，NEXT- PATH属性具有敏感而重要的作用。NEXT-HOP是AS-PATH起始的路由器接口的IP地址。为了深人理解该属性，找们冉次参考图5-10。如图5-10中所指示的那样，对于从AS1通过AS2到x的路由“AS2 AS3 $x$，其属性NEXT-HOP是路由器 $2a$ 左边接口的IP地址。对于从AS1绕过AS2到x的路由“AS3 x”，其NEXT- HOP属性是路由器3d最左边接口的 $IP$ 地址。总的说来,在这个假想的例子中，AS1中的每台路由器都知道了到前缀x的两台BGP路由。
![[NEXTHOP.png]]

#### BGP路由选择算法

##### 热土豆选择(hot potato routing)

- 尽快地把packet送出AS，而不关心总体开销。
- 如上图所示，如果是$1b想访问x$，那么会经由$AS2\rightarrow AS3$ ，因为从$1c$能最快离开$AS1$。如果是$1d$想访问$x$那么会直接到$3d$ ，因为这是离开$AS1$最短路径。

##### 路由器选择算法

- 实践中BGP使用这种算法。对于任何给定的目的地前缀，进入BGP的路由选择算法的输入是到某前缀的所有路由的集合。如果仅有一条这样的路由，BGP则显然选择该路由。如果有多条，就顺序调用以下规则来消除路由，直到只剩下一条路由：
  1. 路由被指派一个本地偏好 $(local \;preference )$ 值作为其属性之一（除了AS- PATH和NEXT-HOP以外)。一条路由的本地偏好可能由该路由器设置或可能由在相同AS中的另一台路由器学习到。本地偏好属性的值是一种策略决定，它完全取决于该 $AS$ 的网络管理员（随后将更为详细地讨论BGP策略问题)具有最高本地偏好值的路由将被选择。
  2. 从余下的路由中（所有都具有相同的最高本地偏好值），将选择具有最短ASPATH的路由。如果该规则是路由选择的唯一规则，则BGP将使用距离向量算法决定路径，其中距离测度使用 $\mathrm{AS}$ 跳的跳数而不是路由器跳的跳数。
  3. 从余下的路由中（所有都具有相同的最高本地偏好值和相同的 $AS- PATH$ 长度）,使用热土豆路由选择，即选择具有最靠近NEXT-HOP路由器的路由。
  4. 如果仍留下多条路由该路由器使用BGP标识符来选择路由

#### BGP路由选择策略

- 指的是在路由选择算法中的第一步，即根据本地偏好属性选择路由，而本地偏好值由本地AS的策略所确定。
- 主要作用是用来过滤流量，例如接入ISP只能接收以内部为目的的流量或者发出以内部为源的流量。如果想以接入ISP作为中转是不被允许的。
